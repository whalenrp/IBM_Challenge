import sys
from AbstractLearner import AbstractLearner
from random import Random

class BaggingLearner(AbstractLearner):
	"""
	Derived class implementation of AbstractLearner. This class implements the learn() 
	and classify() functions using a Bagging approach
	"""

	def __init__(self, trainingInputFile, testInputFile, isMachineReadable, outputFile):
		AbstractLearner.__init__(self, trainingInputFile, testInputFile, 
			isMachineReadable, outputFile)
		self.randForest = list()

	def learn(self):
		"""
		Creates a classification model based on data held in the AbstractLearner's 
		trainingData list-of-lists
		"""

		del self.randForest[:] # Empty the list of previous contents
		randomGen = Random()
		numRows = len(self.trainingData)
#		for _ in range(numRows): # The number of random trees in forest
#			data = list()
#			for _ in range(numRows): # Generate the random tree itself
#				randomNum = randomGen.randrange(numRows)
#				data.append(self.trainingData[randomNum])
#			self.randForest.append(self.makeTree(data))
		self.makeTree(self.trainingData)
		

	def classify(self):
		"""
		Based on the classification model generated by learn(), this function will read from
		the testData list-of-lists in AbstractLearner and output the prediction for each 
		variable
		"""
		print "Function not yet Defined"
		sys.exit(0)
		
	def makeTree(self, data):
		"""
		Returns a tree created from the given data.
		"""
		
		# transpose data
		columns = [list(a) for a in zip(*data)]

		
		self.printListofLists(columns)
		
		# Zip up the continuously valued variables with their classifications and
		# sort by the continuous variables. Then, find the best split of the row
		# for each variable and decide to split on the best variable overall.
		bestSplitOverall = (-1, 0, 0) # (column, splitValue, score)
		for i in range(len(columns)-1):
			tuplesList = sorted(zip(columns[i], columns[len(columns)-1]))
			totalRowValue = 0
			for j in range(len(tuplesList)):
				totalRowValue += 1 if tuplesList[j][1] else -1

			bestSplit = (0, abs(totalRowValue)) # The best split so far is tracked by (index, score)
			curScore = 0
			prevElement = tuplesList[0][0]
			for j in range(1, len(tuplesList)):
				curScore += 1 if tuplesList[j-1][1] else -1
				scoreRightOfSplit = totalRowValue - curScore
				if tuplesList[j][0] != prevElement and abs(curScore - scoreRightOfSplit) > bestSplit[1]:
					bestSplit = (j, abs(curScore - scoreRightOfSplit))
				prevElement = tuplesList[j][0]
			if i == 0:
				bestSplitOverall = (0, tuplesList[bestSplit[0]][0], bestSplit[1])
			elif bestSplit[1] > bestSplitOverall[2]:
				bestSplitOverall = (i, tuplesList[bestSplit[0]][0], bestSplit[1])

			print(tuplesList, bestSplit, bestSplitOverall)
		
			
		print "Function not yet Defined"
		sys.exit(0)
